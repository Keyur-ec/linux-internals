<Dynamic analysis>

gcov [gcc program covrage tool]

dynamic analysis done peace of software that is executed or in execution
its open source
it is use along with gcc

on analysis gcov will determine untested or unexecuted part of code and also detemines number of times a perticualr line executed

to run gcov type below command in terminal
gcc -fprofile-arcs -ftest-coverage main.c -o main 

here 
	-> -fprofile-arcs create .gcda file 
	-> -ftest-coverage create .gcno file
	
now, type below command in terminal
gcov main.gcda

now to see how many times lines are executed in code for that,
vim main.c.gcov 


compiling the source code with -fprofile-arcs and -ftest-coverage 

-ftest-coverage flag causes gcc to add code coverage statistic coverage info. to binary executable

compiling the source code with special flag will add extra info to binary and also records number of times lines have been executed


running the executable file -fprofile-arcs flag causes to create .gcda output profile file


gcov tool performs line coverage and function coverage


< lcov >
its graphical frontend tool for gcov

lcov graphically represents gcc program covarage tool

lcov tool genorated HTML files for the profiling output genorated by gcov tool


lcov --capture --directory . --output-file main.info

genhtml main.info --output-directory . -o newFile


lcov tool capturing profile, profile info generated by gcov from current directory and storing in .info file

genhtml commang generating html filr from .info file from current directory







< process managment >

process : a program which is in the execution is called as process

once the program gets cpu slice time [time slot] becomes process

to see process that started from terminal 
ps -af // here ps means process state

all the process that are running in os 
ps -elf


process states:

1. new state
2. ready state
3. execution state
4. wait

when a process is newly cerated enters into new state and then process moves to ready state where the process is prepering to load and then moves into execution states if its encounterd any sleep or delay calls then it moves into wait state otherwise enters into termination states


[new]	    |---------------->[termination]
  |         |
  |	[execution]------------
  |	    ^		      | 
  v	    |		      v
[ready]<-------------------[wait]



ready queue :

all the processes are maintined as a linklist in ready queue

scheduler will pick the best process out of the ready queue and puts into execution state [best in terms of priority]

numbers of ready queues mainted by os depeds on cpu core



wait queue maintains link list of processes which are suspended due to blocking or delay call [ex. scanf(), sleep(5)]


number of wait queue is based on number of resources, each resource is having its own queue [resources like keyboard, mouse, printer]


process identifiers (PID)

when a process gets created os allocates PID to the processes

PID are unique no two process have will same PID

so when gets termintaed the same PID is used for other processes with delay timeout



there is a process whose PID = 0 is called as core kernal process created during kernal bootup time 

core kernal is responsibale for creating init. proccess in the user space with PID = 1

init. proccess whose PID = 1 inturn creating multiple proccess in user space



to see user proccess in form of tree we can use below command 
pstree 



PCB [program control block] contsins information like pid, ppid, ps [program state], pointer to queue, cpu info. like PC, SP, IP [instruction pointer], general purpose register


<<>>
ex. if we open terminal and open file from terminal so parent of file is terminal[bash]

now, if we exit[quit] from terminal then who is the perent of that file

=: sol. init process will take care of that file until it terminate
<<>>


each and every processes are isolated from each other 
each and every processes maintains its own address space




<process creation>

pid_t fork() // pid_t internally it is int

fork is a system call that is used to create new process

linux os provides a system call called as fork() for creation of new processes from current task


for implimenting concurrent [multitasking operation] application software   

all mordern os supports for multitasking

fork() sys call creates 2^n number of process. where n is number of time fork() called


return values of fork() system call

fork() system call execute once and returns twice ones rertuns the value to the perent process next returns value to the child process

fork() system call to the perent process returns child process pid
fork() system call reeturn 0 to the child process


as perent process should keep track of child processes fork() system call returns child process pid to perent process and return 0 to the child process


